<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>实现一个简单的 AMD 模块加载器 | 追客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
</head>

<body>
  <nav class="app-nav">
  
      
        <a class="active" href="/.">home</a>
        

      
  
      
        <a href="/archives">archive</a>
      
  
      
        <a href="/about">about</a>
      
  
      
        <a href="/atom.xml">rss</a>
      
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2016/02/11/implement-a-simple-AMD-module-loader/">实现一个简单的 AMD 模块加载器</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">February 11 2016</p>
  </section>

  <section class="article-entry">
    <p>(完整代码请看<a href="https://github.com/DrakeLeung/tiny-module-loader" target="_blank" rel="external">GitHub - tiny module loader</a>)</p>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>不了解JavaScript模块化的请看<a href="http://drakeleung.github.io/blog/2016/02/07/JavaScript-Module-A-Beginner-Guide/">「译」JavaScript Modules Part1: A Beginner Guide</a>。</p>
<p>简单来说，AMD规范定义了模块加载的方式是异步的而不是同步。</p>
<p>接着，语法是这样子的：<code>define</code>函数去请求依赖。其中，第一个参数是依赖的模块数组，第二个参数是函数。当依赖都加载完毕之后，就会作为参数，传进这个函数里面。</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>为了探究 AMD 模块加载器的原理，我们不妨尝试着从零开始实现他。</p>
<p>我们只实现一个 <code>define</code> 函数。其他后面再慢慢完善。</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>主要分成3部分：下载依赖，执行依赖并导出，读取依赖并执行回调(递归地)。</p>
<h3 id="u4E0B_u8F7D_u4F9D_u8D56"><a href="#u4E0B_u8F7D_u4F9D_u8D56" class="headerlink" title="下载依赖"></a>下载依赖</h3><p>接受一个依赖模块的URL，然后用Ajax请求。这时会返回包含文件内容的字符串。</p>
<p>这个很简单，只是用<em>Promise</em>简便一点而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getModule.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchDeps = name =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> req = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">    req.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status &lt; <span class="number">400</span>) resolve(req.responseText)</span><br><span class="line">      <span class="keyword">else</span> reject(req.status)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    req.addEventListener(<span class="string">'error'</span>, () =&gt; &#123;</span><br><span class="line">      reject(req.status)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    req.open(<span class="string">'GET'</span>, name, <span class="literal">true</span>)</span><br><span class="line">    req.send(<span class="literal">null</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="u6267_u884C_u4F9D_u8D56"><a href="#u6267_u884C_u4F9D_u8D56" class="headerlink" title="执行依赖"></a>执行依赖</h3><p>由于请求依赖返回的是一个字符串。但我们想要的是把这个字符串当作 JavaScript 代码来执行，解决方法有2种，分别是 <code>eval()</code> 和 <code>new Function()</code>。我们采取后者。</p>
<p>还有一种方法应该可以：动态创建 <code>&lt;script&gt;</code> 标签。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getModule.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentModule = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getModule = code =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    exports: <span class="literal">null</span>,</span><br><span class="line">    exported: <span class="literal">false</span>,</span><br><span class="line">    onExport: []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentModule = <span class="built_in">module</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Function</span> (<span class="string">''</span>, code)() <span class="comment">// work with eval(), as well</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  currentModule,</span><br><span class="line">  getModule</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个我觉得是最难的问题：由于 <code>new Function()</code> 执行的时候，是不返回东西的（其实我并不知道 <code>new Function</code> 的工作原理)。</p>
<p>所以，这个时候依赖虽然是请求回来并执行了，但是他依然还没有导出(<code>exports</code>)。所以，返回的 <code>module</code> 对象的 <code>exports</code> 是 <code>null</code>的。并且，我们还用了一个变量 <code>currentModule</code> 还存储当前的变量。</p>
<h3 id="u5BFC_u51FA_u4F9D_u8D56_u5E76_u6267_u884C_u56DE_u8C03_u51FD_u6570"><a href="#u5BFC_u51FA_u4F9D_u8D56_u5E76_u6267_u884C_u56DE_u8C03_u51FD_u6570" class="headerlink" title="导出依赖并执行回调函数"></a>导出依赖并执行回调函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myDefine.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#123;</span></span><br><span class="line"><span class="comment">//   currentModule,</span></span><br><span class="line"><span class="comment">//   getModule</span></span><br><span class="line"><span class="comment">// &#125; from './getModule'</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// import &#123;fetchDeps&#125; from './fetchDeps'</span></span><br><span class="line"><span class="comment">// import &#123;whenDepsExported&#125; from './whenDepsExported'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> define = (deps, callback) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> myModule = currentModule <span class="comment">// #0</span></span><br><span class="line">  <span class="keyword">const</span> getDeps = deps.map(fetchDeps)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.all(getDeps)</span><br><span class="line">    .then(codes =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> modules = codes.map(getModule)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// #1</span></span><br><span class="line">      modules.forEach(m =&gt;</span><br><span class="line">        !m.exported &amp;&amp; m.onExport.push(() =&gt;</span><br><span class="line">          whenDepsExported(callback, modules, myModule)</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      whenDepsExported(callback, modules, myModule) <span class="comment">// #2</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#0</code> 我们把 <code>currentModule</code> 赋给一个局部变量，这样使得每个 <code>define</code> 都有自己的「模块」。这个也是困惑了我好久的一步。我也似懂非懂，因为反正已经 work 起来了= =</p>
<p>这个时候问题就来了。因为我们需要递归地加载依赖，那么，肯定是加载最外面的依赖，然后才到里面。如果没有了 <code>#1</code>，那么就会执行 <code>#2</code>，这样就会导致和想我们想要的相反，即先执行最里面的依赖的回调，再执行外面的。</p>
<p>因此，我们把最里面的模块先放到一个数组里面，然后当他的依赖执行完之后，再去执行他的回调，这时他的回调的参数才有值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// whenDepsExported.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> whenDepsExported = (cb, deps, myModule) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!deps.every(dep =&gt; dep.exported)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// params for 'callback of define'</span></span><br><span class="line">  <span class="keyword">let</span> args = deps.map(dep =&gt; dep.exports)</span><br><span class="line">  <span class="keyword">let</span> exports = cb.apply(<span class="literal">null</span>, args)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// #0</span></span><br><span class="line">  <span class="keyword">if</span> (myModule) &#123;</span><br><span class="line">    myModule.exports = exports</span><br><span class="line">    myModule.exported = <span class="literal">true</span></span><br><span class="line">    myModule.onExport.forEach(f =&gt; f())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> exports</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#0</code> 中，我们导出了依赖，并且执行了 <code>onExport</code> 的回调函数。</p>
<h2 id="Wrap_up"><a href="#Wrap_up" class="headerlink" title="Wrap up"></a>Wrap up</h2><p>原理看起来不是很难，但自己实现一遍还是挺难的。</p>
<p>不过 AMD，CommonJS 这些规范倒是改善了 JavaScript 模块系统，使得 JavaScript 能够在规模较大的项目中更加容易开发，以及维护。</p>
<p>(完整代码请看<a href="https://github.com/DrakeLeung/tiny-module-loader" target="_blank" rel="external">GitHub - tiny module loader</a>)</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><ul>
<li><a href="http://eloquentjavascript.net/10_modules.html" target="_blank" rel="external">eloquent javascript - modules</a></li>
</ul>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="http://7xrcp8.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> 追客 </p>
      <p class="subtitle"> You are the JavaScript in my HTML </p>
    <div>
  </section>

  <section class="share-btns">
    <p> share it if you like it~ </p>
    <!-- <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=(完整代码请看<a href="http"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>
 -->
  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = 'http://drakeleung.github.io/blog/2016/02/11/implement-a-simple-AMD-module-loader/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
