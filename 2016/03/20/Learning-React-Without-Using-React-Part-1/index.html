<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>「译」Learning React Without Using React Part 1 | ly你个c</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css" type="text/css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2016/03/20/Learning-React-Without-Using-React-Part-1/">「译」Learning React Without Using React Part 1</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">March 20 2016</p>
  </section>

  <section class="article-entry">
    <p><em>原文链接：<a href="https://medium.com/javascript-inside/learn-the-concepts-part-1-418952d968cb#.femmquo5d" target="_blank" rel="external">Learning React Without Using React Part 1</a></em></p>
<p>当我们谈起 React 的时候总是有很多疑惑。下面简单地介绍了 React 以及他的一些底层原理。</p>
<p>当你完成 Part1 和 Part2 之后，你会学到什么呢？你也许就会知道你为什么需要 React 以及 Redux 类似的 state container （状态管理器）。</p>
<p>然而，<strong>你并不需要学习</strong>: JSX，ES6/ES*，Webpack，Hot Reloading，也不需要理解 Virtual DOM，甚至不需要 React 本身。</p>
<p>那么，我们首先要做的是：</p>
<p>阅读 <a href="https://github.com/tastejs/todomvc/blob/gh-pages/examples/jquery/js/app.js" target="_blank" rel="external">Jquery 实现的 TodoMVC</a> 的代码。</p>
<p>也许你会注意到有一个叫 <code>render</code> 的方法，他会在某个事件触发或者数据更新的时候被调用。现在，我们从头来实现一个例子：当 <code>input</code> 的值改变时，调用 <code>render</code> 函数，并且更新 DOM 元素。（<a href="http://plnkr.co/edit/fjQbQwZpQlhd5wXoc9J8?p=preview" target="_blank" rel="external">点击这里可查看完整的代码</a>）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> state = &#123;value: <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#input'</span>).on(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  state.value = $(<span class="keyword">this</span>).val().trim()</span><br><span class="line">  render()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#output'</span>).html(state.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()</span><br></pre></td></tr></table></figure>
<p>我们使用一个全局变量 <code>state</code> 来同步所有的东西。也就是说，当 <em>input</em> 的值改变时会更新两样东西：</p>
<ol>
<li>更新整个应用的 <code>state</code></li>
<li>更新 DOM（根据应用当前的 <code>state</code> 来调用 <code>render</code> 函数）</li>
</ol>
<p>先记住这些，我们等一下就会返回来。</p>
<p>现在，我们有了一个新想法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;div&gt;'</span> + text + <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，调用 <code>output(foo)</code> 就会返回 <code>&#39;&lt;div&gt;foo&lt;/div&gt;&#39;</code>。</p>
<p>那么接下来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h2</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;h2&gt;'</span> + text + <span class="string">'&lt;/h2&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;div&gt;'</span> + text + <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">header</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> div(h2(text))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(header(<span class="string">'foo'</span>) === <span class="string">'&lt;div&gt;&lt;h2&gt;foo&lt;/h2&gt;&lt;/div&gt;'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的函数都是基于一个 <em>text(input)</em> 然后返回一个 <em>string(text)</em> 。调用 <code>header</code> 的时候传入相同的参数（<em>input</em>），都会得到相同的字符串（<em>output</em>）。如果你在想思考 React 中的 <strong>stateless functions</strong> 的话，那么这个其实就是一个简化版。只是 Stateless functions 会返回一个 React Element 而不是一个简单的 string ，但是思路是一样的。</p>
<p>既然这样，我们就把这个想法应用到我们之前的例子中。我们添加了一个 <code>button</code>，用来添加 todo item 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> state = &#123;items: [], id: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#add'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = $(<span class="string">'#input'</span>).val().trim()</span><br><span class="line">  $(<span class="string">'#input'</span>).val(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  state.items.push(&#123;</span><br><span class="line">    id: state.id++,</span><br><span class="line">    text: value,</span><br><span class="line">    completed: <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  render()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#list'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> toggleId = <span class="built_in">parseInt</span>($(<span class="keyword">this</span>).attr(<span class="string">'id'</span>))</span><br><span class="line"></span><br><span class="line">  state.items.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    el.id === toggleId &amp;&amp; (el.completed = !el.completed)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  render()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> items = state.items.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> completed = item.completed ? <span class="string">'completed'</span> : <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;li class="item + '</span> + completed + <span class="string">'" id="'</span> + item.id + <span class="string">'"&gt;('</span> +</span><br><span class="line">      item.id + <span class="string">') '</span> + item.text + <span class="string">'&lt;/li&gt;'</span></span><br><span class="line">  &#125;).join(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> html = <span class="string">'&lt;ul&gt;'</span> + items = <span class="string">'&lt;/ul&gt;'</span></span><br><span class="line"></span><br><span class="line">  $(<span class="string">'#list'</span>).html(html)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()</span><br></pre></td></tr></table></figure>
<p>效果图如下。我们的应用现在可以显示所有的 todo，也可以改变每个 todo 的状态（进行中或者完成）。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*ouOYh6bI3q_8y1XLCoVD-A.png" alt="simple todo lsit"></p>
<p>在上面，我们定义了两个 <code>click</code> 事件，当他们触发时就会更新我们的 <code>state</code> 以及调用 <code>render</code> 函数。而 <code>render</code> 函数会创建一个 todo list 。 <code>state</code> 作为中间媒介，简化了事件和 DOM 元素之间的交互，而不是<strong> 通过事件来直接操作 DOM </strong> （不需要定义每个 DOM 元素和每个事件以及他们之间的关系）。当某个 <em>action</em>（如 click 事件） 触发之后，<code>state</code> 就会更新，接着调用 <code>render</code> 函数，最后我们的应用就会更新。这样一来，就简化了好多复杂的交互。</p>
<p>上面的例子是很好的，我们不妨再来重构他。</p>
<p>可以看到，<code>render</code> 函数有一点乱。我们不妨创建一个函数，他接收一个参数（input），然后基于这个参数返回一个字符串（output）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ItemRow</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> className = props.completed ? <span class="string">' item completed'</span> : <span class="string">'item'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;li className="'</span> + className +<span class="string">' "&gt;'</span> + props.text + <span class="string">'&lt;/li&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ItemsList</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;ul&gt;'</span> + props.items.map(ItemRow).join(<span class="string">''</span>) + <span class="string">'&lt;/ul&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看，现在我们的 <code>render</code> 函数优美多了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#list'</span>).html(ItemsList(&#123;</span><br><span class="line">    items: state.items</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>render</code> 函数并不知道 <code>state</code> 是什么，而是期望一个 <em>input</em> 作为参数呢？好吧，现在我们可以重构一下 <code>render</code> 函数，他期望接收一个 <code>props</code> 对象（这其实就是 React Component 所期望的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#list'</span>).html(ItemsList(&#123;</span><br><span class="line">    items: props.items</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，<code>render</code> 函数并不依赖外部的状态（state），这使得我们在调用 <code>render</code> 时可以随便传入一个 <em>input</em> ，也就意味着我们的应用重新渲染时，相同的 <em>input</em> 会有相同的 <em>output</em> 。需要注意的是，DOM 操作其实是一个 side effect，但是现在我们暂时忽略他。</p>
<p>把 <code>state</code> 从 <code>render</code> 函数中分离出来，可以使得我们很容易实现 <code>Undo/Redo</code>。这也意味着每当 <em> 当前的 state </em> 改变时，我们能够创建一个 history ，保存这个当前的 state 。</p>
<p>另外一个优化就是传一个 root node 作为参数，而不是写死在 <code>render</code> 函数里面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">props, node</span>) </span>&#123;</span><br><span class="line">  node.html(ItemsList(&#123;</span><br><span class="line">    items: props.items</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们可以这样调用 <code>render</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render(state, $(<span class="string">'#list'</span>))</span><br></pre></td></tr></table></figure>
<p>我们会很容易想到：当 <code>state</code> 改变的时候，能不能自动地更新应用？也就是，不用手动地调用 <code>render</code> 函数。</p>
<p>现在，我们来创建一个 <em>store</em> ，他的作用是当 <code>state</code> 改变之后，就立马调用 <code>render</code> 函数。下面的实现虽然简单，但也是一个 advanced state container 的雏形。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _state = initialState || &#123;&#125;,</span><br><span class="line">    _listeners = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateListeners</span> (<span class="params">state</span>) </span>&#123;</span><br><span class="line">    _listeners.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">listener</span>) </span>&#123;</span><br><span class="line">      listener.cb(state)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    setState: <span class="function"><span class="keyword">function</span> (<span class="params">state</span>) </span>&#123;</span><br><span class="line">      _state = state</span><br><span class="line">      updateListeners(state)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getState: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> _state</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    onUpdate: <span class="function"><span class="keyword">function</span> (<span class="params">name, cb</span>) </span>&#123;</span><br><span class="line">      _listeners.push(&#123;name: name, cb: cb&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们更新 <code>state</code> 只需要简单地调用 <code>setState</code> 方法。只要 <code>state</code> 一改变，我们的 <code>render</code> 函数就会被调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> store = createStore(store)</span><br><span class="line"></span><br><span class="line">store.onUpdate(<span class="string">'rootRender'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">state</span>) </span>&#123;</span><br><span class="line">  render(state, $(<span class="string">'#list'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="http://plnkr.co/edit/fjQbQwZpQlhd5wXoc9J8?p=preview" target="_blank" rel="external">点击这里可查看完整的代码</a></p>
<p><strong> 现在我们学会了什么？ </strong> 我们知道了简单的单向数据流（one-way data flow）的原则。我们给 <code>render</code> 函数传了一个 <code>state</code> 参数，然后 <code>state</code> 就会像流水一样，流到 <code>render</code> 函数的每个层次中。比如，<code>ItemRow</code> 函数需要 <code>ItemsList</code> 给他传进正确的参数。</p>
<p>我们已经创建了多个组件（component），并且我们把这些组件组合（compose）在一起。回想一下前面的 <code>header</code> 例子，我们把 <code>div</code> 和 <code>h2</code> 函数组合成了一个 <code>header</code> 函数。并且，这些函数都是 <em>pure function</em> ，这使得所有更新都是可预测的。</p>
<p>并且，我们使用了 <em>store</em> 来管理我们的 <code>state</code>。</p>
<p>而，React 会用更好更优美的方法来实现上面这些东西。组件（组合），使用 Virtual DOM 优化渲染，单向数据流等等。</p>
<blockquote>
<p>…we can focus on examining React’s true strengths: composition, unidirectional data flow, freedom from DSLs, explicit mutation and static mental model.</p>
</blockquote>
<p>From <a href="https://medium.com/@dan_abramov/youre-missing-the-point-of-react-a20e34a51e1a" target="_blank" rel="external">Dan Abramov - you’re missing the point of react</a></p>
<p>我们可以优化的东西还有很多，比如继续优化 state container，重构我们的 listeners，实现 undo/redo，以及更多更好的 feature。<strong>这些东西我们都会在 Part 2 呈现</strong>。</p>
<p><em>原文链接：<a href="https://medium.com/javascript-inside/learn-the-concepts-part-1-418952d968cb#.femmquo5d" target="_blank" rel="external">Learning React Without Using React Part 1</a></em></p>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="http://7xrcp8.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> ly你个c </p>
      <p class="subtitle"> You are the JavaScript in my HTML </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=<em>原文链接：<a href="ht"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = 'http://drakeleung.github.io/blog/2016/03/20/Learning-React-Without-Using-React-Part-1/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
