<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Scope(1) - Nested Scope | 追客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/blog/favicon.ico">
  <link rel="stylesheet" href="/blog/css/app.css" type="text/css">
  <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'>
</head>

<body>
  <nav class="app-nav">
  
      
        <a class="active" href="/blog/.">home</a>
        

      
  
      
        <a href="/blog/archives">archive</a>
      
  
      
        <a href="/blog/about">about</a>
      
  
      
        <a href="/blog/atom.xml">rss</a>
      
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/blog/2015/07/09/Scope-1-Nested-Scope/">Scope(1) - Nested Scope</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">July 09 2015</p>
  </section>

  <section class="article-entry">
    <h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p><em>nested scope</em>就是所谓的嵌套作用域, 顾名思义就是作用域之间具有嵌套的关系.<br>那么, 为什么我们需要的nested scope呢?</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>我们做出一下的假设:</p>
<blockquote>
<p>从头到尾只有一个socpe, 没有什么多个, 也没有什么嵌套关系.</p>
</blockquote>
<p>这样的话, 我们所有的变量声明, 函数声明都会放到这个<strong>唯一的scope</strong>里面去. 那么, 当数量变大的时候, 程序的性能就会降低. 比如我们要在茫茫变量中找出一个小小的变量, 这性能不就降低了吗?</p>
<p>为了改进他, 我们又做出了以下的假设:</p>
<blockquote>
<p>其实不止一个socpe, 可以有多个scope. 但是scope之间美柚嵌套关系.</p>
</blockquote>
<p>很容易看出, 这次的假设比第一次的好多了. 但是问题又来了, 如果2个scope所存放的变量有很多是相同的, 既然是相同的, 那么我们很容易就想到要<strong>复用</strong>他们. 怎么复用呢? 这个时候, 我们就给这些需要复用的scope加上一次嵌套关系:</p>
<blockquote>
<p>外部的scope嵌套着内部的scope, 内部的scope可以使用外部的scope的变量, 但反之不行!</p>
</blockquote>
<p>这样以来, 我们就可以不同scope之间就可以共用相同的变量. 这是极好的~<br>但是, 我们要怎样才可以创建出多个scope呢?</p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>在JavaScript中, 有3种不同的scope. 分别是<strong>global scope</strong>, <strong>block scope</strong>以及<strong>function scope</strong>.</p>
<h3 id="Global_Scope"><a href="#Global_Scope" class="headerlink" title="Global Scope"></a>Global Scope</h3><p>global scope(全局作用域)是不需要创建的, 只要你执行JavaScript文件的话, 他就被自动创建.</p>
<p>他是最外层的scope. 也就是说, 他可以嵌套其他作用域, 不可以被其他scope嵌套.</p>
<p>在浏览器环境下, global scope可以看做为<code>window</code>这个对象.</p>
<h3 id="Block_Scope"><a href="#Block_Scope" class="headerlink" title="Block Scope"></a>Block Scope</h3><p>block scope(块级作用域)指的是用<code>{}</code>(大括号)创建一个scope. 也就是说, <code>{}</code>内的变量定义和声明都是属于这个<code>{}</code>所创建的scope.</p>
<p>在ES6中, 我们可以使用<code>let</code>这个keyword来实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// Reference Error</span></span><br></pre></td></tr></table></figure>
<p>但是, 在ES6之前呢? 我们要怎样才能创建一个block scope呢? 一个trick就是使用<code>try-catch</code>.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (foo) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo);  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中, <code>foo</code>这个keyword只能在<code>catch</code>块里面使用. 但是, 这种写法也太丑了. 因此, 在ES6之前可以说是没有block scope的.</p>
<h2 id="Function_Scope"><a href="#Function_Scope" class="headerlink" title="Function Scope"></a>Function Scope</h2><p>当执行一个函数的时候, 就会创建一个属于这个函数的作用域. 当执行完这个函数之后, 理论上这个作用域是会被垃圾回收器回收的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中, 一个有3个scope. 分别是global scope &gt; foo &gt; bar(<code>&gt;</code>表示嵌套关系).<br>Engine和各个scope之间的对话.</p>
<p>Engine: 你好<code>bar scope</code>, 我想要一个<code>a</code>的RHS, 请问你有吗?<br>bar scope: 不好意思, 我没有. 你可以去问问我的外层作用域foo scope.<br>Engine: 你好<code>foo scope</code>, 请问你有见过<code>a</code>吗?<br>foo scope: 当然! 这就给你.<br>Engine: 那太好了. 既然找到的话, 我就不需要再向上层的作用域找了.  </p>
<p>从上面的对话中, 我们可以很容易知道: 当要查找一个变量的时候, 首先会在当前所在的作用域寻找, 如果没有找到的话, 就向上找, 直到global scope. 这个过程其实就叫做<strong>identifier resolution</strong>(或者identifier look-up).</p>
<p>接下来, 我们再来优化一下上面的例子. 例子中的<code>bar</code>函数只是为了打印一个<code>a</code>, 我们以后再也不会引用到<code>bar</code>这个变量名. 但这个变量却污染了foo scope. 有没有办法既可以打印<code>a</code>又可以不创建一个变量名呢? 答案就是利用<strong>IIFE</strong>(Immediately invoked function express).<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先, 用<code>()</code>包住整个function body就表明了这个是一个expression, 接着用<code>()</code>来调用这个function expression.<br>对于IIFE还有其他写法, 你可以选择自己喜欢的口味~</p>
<p>IIFE是很常见的, 因为他在调用一个函数的同时也<strong>避免了作用域的污染</strong>. 这是非常值得我们学习的.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>总的来说, nested scope是为了可以共用作用域而产生的, 也就是说内部的scope可以访问外部scope. 而JavaScript有3种作用域global scope, block scope以及function scope. 其中, function scope是最主要的, 并且要懂得其中的IIFE.</p>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="/blog/images/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> 追客 </p>
      <p class="subtitle"> 热爱生活，热爱编程，Web前端见习魔法师 </p>
    <div>
  </section>

  <section class="share-btns">
    <p> share it if you like it~ </p>
    <!-- <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text= id="What"><a href=""
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>
 -->
  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = 'http://drakeleung.github.io/blog/2015/07/09/Scope-1-Nested-Scope/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

  <script src="/blog/js/app.js" type="text/javascript"></script>
</body>
</html>
